{"version":3,"sources":["/Users/matt/Sites/MarketEdge/platform-wrapper/frontend/src/services/auth.ts"],"sourcesContent":["import { apiService } from './api'\nimport { LoginRequest, TokenResponse, User } from '@/types/auth'\nimport Cookies from 'js-cookie'\n// PRODUCTION FIX: Remove timer-utils dependency to avoid function reference issues\n// import { safeClearInterval, safeSetInterval, ensureTimerFunctions } from '@/utils/timer-utils'\n\ninterface EnhancedTokenResponse {\n  access_token: string\n  refresh_token: string\n  token_type: string\n  expires_in: number\n  user: User\n  tenant: {\n    id: string\n    name: string\n    industry: string\n    subscription_plan: string\n  }\n  permissions: string[]\n}\n\ninterface EnhancedUserResponse {\n  user: User & {\n    created_at?: string\n    updated_at?: string\n  }\n  tenant: {\n    id: string\n    name: string\n    industry: string\n    subscription_plan: string\n  }\n  permissions: string[]\n  session: {\n    authenticated: boolean\n    tenant_isolated: boolean\n  }\n}\n\ninterface LogoutRequest {\n  refresh_token?: string\n  all_devices?: boolean\n}\n\nexport class AuthService {\n  private refreshTokenPromise: Promise<EnhancedTokenResponse> | null = null\n  private loginPromise: Promise<EnhancedTokenResponse> | null = null\n  private readonly tokenRefreshThreshold = 5 * 60 * 1000 // 5 minutes in milliseconds\n  private processedAuthCodes: Set<string> = new Set()\n\n  /**\n   * Emergency authentication method using form data to bypass CORS preflight\n   * This method uses application/x-www-form-urlencoded instead of application/json\n   * to avoid triggering browser preflight requests\n   */\n  private async emergencyAuthLogin(loginData: LoginRequest & { state?: string }): Promise<EnhancedTokenResponse> {\n    console.log('EMERGENCY CORS FIX: Making authentication request with form data')\n    \n    const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL\n    const authUrl = `${baseUrl}/api/v1/auth/login`\n    \n    // Create form data to avoid preflight request\n    const formData = new URLSearchParams()\n    formData.append('code', loginData.code)\n    formData.append('redirect_uri', loginData.redirect_uri)\n    if (loginData.state) {\n      formData.append('state', loginData.state)\n    }\n    \n    const response = await fetch(authUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        // Don't include Authorization header for login request\n      },\n      credentials: 'include', // Include cookies\n      body: formData\n    })\n    \n    if (!response.ok) {\n      const errorText = await response.text()\n      console.error('EMERGENCY AUTH LOGIN FAILED:', response.status, errorText)\n      throw new Error(`Authentication failed: ${response.status}`)\n    }\n    \n    const result = await response.json()\n    console.log('EMERGENCY AUTH LOGIN SUCCESS - Response structure:', {\n      hasAccessToken: !!result.access_token,\n      hasRefreshToken: !!result.refresh_token,\n      hasUser: !!result.user,\n      tokenType: result.token_type,\n      expiresIn: result.expires_in,\n      keys: Object.keys(result)\n    })\n    return result\n  }\n\n  async login(loginData: LoginRequest & { state?: string }): Promise<EnhancedTokenResponse> {\n    // Improved circuit breaker: Only prevent true duplicates\n    const authCodeKey = loginData.code.substring(0, 20); // Use more of the code for uniqueness\n    \n    if (this.processedAuthCodes.has(authCodeKey)) {\n      console.warn('Duplicate authentication code detected:', authCodeKey + '...')\n      // Instead of throwing, wait for the existing promise\n      if (this.loginPromise) {\n        console.log('Waiting for existing login request to complete...')\n        return this.loginPromise;\n      }\n      // If no promise but code is processed, clear it and continue\n      this.processedAuthCodes.delete(authCodeKey);\n    }\n\n    // Only prevent concurrent requests if one is actively in progress\n    if (this.loginPromise) {\n      console.log('Login request already in progress, waiting for completion...')\n      try {\n        return await this.loginPromise;\n      } catch (error) {\n        // If the existing promise failed, clear it and try again\n        this.loginPromise = null;\n        console.log('Previous login failed, retrying...')\n      }\n    }\n\n    // Mark this auth code as being processed\n    this.processedAuthCodes.add(authCodeKey)\n    console.log('Processing authentication code:', authCodeKey + '...')\n\n    console.log('Initiating login request to backend')\n    \n    this.loginPromise = (async () => {\n      try {\n        // EMERGENCY CORS FIX: Use form data to avoid preflight request\n        console.log('EMERGENCY CORS FIX: Using form data for authentication request')\n        const response = await this.emergencyAuthLogin(loginData)\n        \n        console.log('Login response received from backend')\n        \n        // ENHANCED FIX: Store token metadata with verification\n        console.log('About to call setTokens with response:', {\n          hasAccessToken: !!response.access_token,\n          hasRefreshToken: !!response.refresh_token,\n          tokenType: response.token_type\n        })\n        \n        // Store tokens and verify immediately\n        this.setTokens(response)\n        \n        // CRITICAL: Verify token was stored before proceeding\n        const verifyToken = this.getToken()\n        if (!verifyToken) {\n          console.error('❌ CRITICAL: Token storage failed during login!')\n          throw new Error('Token storage failed - please try logging in again')\n        }\n        \n        console.log('✅ Token storage verified successfully')\n        this.setUserData(response.user, response.tenant, response.permissions)\n        \n        // Clean up processed auth codes (keep only recent ones to prevent memory leak)\n        if (this.processedAuthCodes.size > 10) {\n          this.processedAuthCodes.clear()\n        }\n        \n        return response\n      } catch (error: any) {\n        // Remove the failed auth code from processed set to allow retry\n        this.processedAuthCodes.delete(authCodeKey)\n        \n        console.error('Login request failed:', error)\n        \n        // Handle specific backend errors\n        if (error?.response?.status === 429) {\n          throw new Error('Too many login attempts. Please wait and try again.')\n        } else if (error?.response?.status === 400) {\n          throw new Error('Invalid authorization code. Please try logging in again.')\n        } else if (error?.response?.status === 401) {\n          throw new Error('Authentication failed. Please try logging in again.')\n        } else if (error?.message?.includes('ERR_INSUFFICIENT_RESOURCES')) {\n          throw new Error('Server overloaded. Please wait and try again.')\n        }\n        \n        throw error\n      } finally {\n        // Clear the login promise after completion\n        this.loginPromise = null\n      }\n    })()\n\n    return this.loginPromise\n  }\n\n  async refreshToken(): Promise<EnhancedTokenResponse> {\n    // Prevent multiple concurrent refresh requests\n    if (this.refreshTokenPromise) {\n      return this.refreshTokenPromise\n    }\n\n    const refreshToken = this.getRefreshToken()\n    if (!refreshToken) {\n      throw new Error('No refresh token available')\n    }\n\n    this.refreshTokenPromise = apiService.post<EnhancedTokenResponse>('/auth/refresh', {\n      refresh_token: refreshToken\n    })\n\n    try {\n      const response = await this.refreshTokenPromise\n      this.setTokens(response)\n      this.setUserData(response.user, response.tenant, response.permissions)\n      return response\n    } catch (error) {\n      // If refresh fails, clear tokens and redirect to login\n      this.clearTokens()\n      throw error\n    } finally {\n      this.refreshTokenPromise = null\n    }\n  }\n\n  async getCurrentUser(): Promise<EnhancedUserResponse> {\n    try {\n      return await apiService.get<EnhancedUserResponse>('/auth/me')\n    } catch (error: any) {\n      if (error?.response?.status === 401) {\n        // Try to refresh token and retry\n        try {\n          await this.refreshToken()\n          return await apiService.get<EnhancedUserResponse>('/auth/me')\n        } catch (refreshError) {\n          this.clearTokens()\n          throw refreshError\n        }\n      }\n      throw error\n    }\n  }\n\n  async getAuth0Url(redirectUri: string, additionalScopes?: string[], organizationHint?: string): Promise<{\n    auth_url: string\n    redirect_uri: string\n    scopes: string[]\n    organization_hint?: string\n  }> {\n    const params = new URLSearchParams({\n      redirect_uri: redirectUri\n    })\n    \n    if (additionalScopes?.length) {\n      params.append('additional_scopes', additionalScopes.join(','))\n    }\n\n    if (organizationHint) {\n      params.append('organization_hint', organizationHint)\n    }\n\n    try {\n      return await apiService.get<{\n        auth_url: string\n        redirect_uri: string\n        scopes: string[]\n        organization_hint?: string\n      }>(`/auth/auth0-url?${params}`)\n    } catch (error: any) {\n      if (error?.message?.includes('timeout') || error?.code === 'ECONNABORTED') {\n        throw new Error('Request timed out. The backend may be starting up - please wait a moment and try again.')\n      }\n      throw error\n    }\n  }\n\n  async logout(allDevices: boolean = false): Promise<void> {\n    const refreshToken = this.getRefreshToken()\n    \n    try {\n      await apiService.post('/auth/logout', {\n        refresh_token: refreshToken,\n        all_devices: allDevices\n      } as LogoutRequest)\n    } catch (error) {\n      console.warn('Logout API call failed:', error)\n      // Continue with local cleanup even if server logout fails\n    }\n\n    // Enhanced session cleanup\n    this.performCompleteSessionCleanup()\n    \n    // Redirect to login page\n    window.location.href = '/login'\n  }\n\n  private performCompleteSessionCleanup(): void {\n    // Clear tokens and user data\n    this.clearTokens()\n    this.clearUserData()\n\n    // Clear all localStorage with auth-related data\n    const keysToRemove = [\n      'current_user',\n      'tenant_info', \n      'user_permissions',\n      'token_expires_at',\n      'auth_state',\n      'last_activity'\n    ]\n    \n    keysToRemove.forEach(key => {\n      localStorage.removeItem(key)\n    })\n\n    // Clear all sessionStorage\n    sessionStorage.clear()\n\n    // Clear intervals - PRODUCTION FIX: Use native clearInterval\n    if (typeof window !== 'undefined') {\n      const refreshInterval = (window as any).__authRefreshInterval\n      const timeoutInterval = (window as any).__sessionTimeoutInterval\n      \n      if (refreshInterval) {\n        try {\n          if (typeof window.clearInterval === 'function') {\n            window.clearInterval(refreshInterval)\n          }\n          delete (window as any).__authRefreshInterval\n        } catch (error) {\n          console.warn('Error clearing refresh interval:', error)\n        }\n      }\n      \n      if (timeoutInterval) {\n        try {\n          if (typeof window.clearInterval === 'function') {\n            window.clearInterval(timeoutInterval)\n          }\n          delete (window as any).__sessionTimeoutInterval\n        } catch (error) {\n          console.warn('Error clearing timeout interval:', error)\n        }\n      }\n    }\n\n    // Clear any cached data from API service\n    if ((apiService as any).clearCache) {\n      (apiService as any).clearCache()\n    }\n\n    // Clear browser history state related to auth\n    if (typeof window !== 'undefined' && window.history.replaceState) {\n      const currentUrl = window.location.pathname\n      window.history.replaceState(null, '', currentUrl)\n    }\n\n    console.info('Complete session cleanup performed')\n  }\n\n  async checkSession(): Promise<{\n    authenticated: boolean\n    user_id: string\n    tenant_id: string\n    role: string\n    active: boolean\n  }> {\n    return apiService.get('/auth/session/check')\n  }\n\n  async extendSession(): Promise<{\n    extend_recommended: boolean\n    message: string\n    expires_soon: boolean\n  }> {\n    return apiService.post('/auth/session/extend')\n  }\n\n  getToken(): string | undefined {\n    // ENHANCED FIX: Prioritize localStorage for local development\n    const localToken = localStorage.getItem('access_token')\n    if (localToken) {\n      console.debug('✅ Token retrieved from localStorage')\n      return localToken\n    }\n    \n    // Fallback to cookies\n    const cookieToken = Cookies.get('access_token')\n    if (cookieToken) {\n      console.debug('✅ Token retrieved from cookies')\n      return cookieToken\n    }\n    \n    console.debug('⚠️  No access token found in either localStorage or cookies')\n    return undefined\n  }\n\n  getRefreshToken(): string | undefined {\n    // ENHANCED FIX: Prioritize localStorage for local development\n    const localToken = localStorage.getItem('refresh_token')\n    if (localToken) {\n      console.debug('✅ Refresh token retrieved from localStorage')\n      return localToken\n    }\n    \n    // Fallback to cookies\n    const cookieToken = Cookies.get('refresh_token')\n    if (cookieToken) {\n      console.debug('✅ Refresh token retrieved from cookies')\n      return cookieToken\n    }\n    \n    console.debug('⚠️  No refresh token found in either localStorage or cookies')\n    return undefined\n  }\n\n  isAuthenticated(): boolean {\n    const token = this.getToken()\n    const user = this.getStoredUser()\n    return !!(token && user)\n  }\n\n  getUserPermissions(): string[] {\n    try {\n      const permissions = localStorage.getItem('user_permissions')\n      return permissions ? JSON.parse(permissions) : []\n    } catch {\n      return []\n    }\n  }\n\n  hasPermission(permission: string): boolean {\n    const permissions = this.getUserPermissions()\n    return permissions.includes(permission)\n  }\n\n  hasAnyPermission(requiredPermissions: string[]): boolean {\n    const userPermissions = this.getUserPermissions()\n    return requiredPermissions.some(perm => userPermissions.includes(perm))\n  }\n\n  getUserRole(): string | null {\n    const user = this.getStoredUser()\n    return user?.role || null\n  }\n\n  getTenantInfo(): { id: string; name: string; industry: string; subscription_plan: string } | null {\n    try {\n      const tenantData = localStorage.getItem('tenant_info')\n      return tenantData ? JSON.parse(tenantData) : null\n    } catch {\n      return null\n    }\n  }\n\n  shouldRefreshToken(): boolean {\n    // Check if we should proactively refresh the token\n    const tokenExpiry = localStorage.getItem('token_expires_at')\n    if (!tokenExpiry) return false\n\n    const expiryTime = new Date(tokenExpiry).getTime()\n    const currentTime = Date.now()\n    \n    return (expiryTime - currentTime) <= this.tokenRefreshThreshold\n  }\n\n  // Auto-refresh token if needed\n  async ensureValidToken(): Promise<string | null> {\n    const token = this.getToken()\n    if (!token) return null\n\n    if (this.shouldRefreshToken()) {\n      try {\n        await this.refreshToken()\n        return this.getToken()\n      } catch (error) {\n        console.error('Token refresh failed:', error)\n        return null\n      }\n    }\n\n    return token\n  }\n\n  private setTokens(tokenResponse: EnhancedTokenResponse): void {\n    // ENHANCED FIX: Dual storage strategy for maximum compatibility\n    // Store in both cookies AND localStorage for local development reliability\n    \n    if (tokenResponse.access_token) {\n      const isProduction = process.env.NODE_ENV === 'production'\n      const isLocalhost = typeof window !== 'undefined' && window.location.hostname === 'localhost'\n      const useSecure = isProduction && !isLocalhost\n      \n      // CRITICAL FIX: Always store in localStorage for cross-origin local development\n      localStorage.setItem('access_token', tokenResponse.access_token)\n      console.log('✅ Token stored in localStorage for cross-origin compatibility')\n      \n      // ALSO try cookies for same-origin requests\n      try {\n        Cookies.set('access_token', tokenResponse.access_token, {\n          expires: new Date(Date.now() + (tokenResponse.expires_in || 3600) * 1000),\n          secure: useSecure,\n          sameSite: 'lax'\n        })\n        \n        // Verify cookie storage\n        const storedToken = Cookies.get('access_token')\n        if (storedToken) {\n          console.log('✅ Token also stored in cookies')\n        } else {\n          console.log('⚠️  Cookie storage failed (common in local dev) - localStorage will be used')\n        }\n      } catch (cookieError) {\n        console.log('⚠️  Cookie storage error (using localStorage):', cookieError)\n      }\n      \n      // VERIFICATION: Ensure token is accessible\n      const verifyToken = this.getToken()\n      if (verifyToken) {\n        console.log('✅ Token verification successful - accessible via getToken()')\n      } else {\n        console.error('❌ CRITICAL: Token storage verification failed!')\n      }\n    }\n    \n    if (tokenResponse.refresh_token) {\n      const isProduction = process.env.NODE_ENV === 'production'\n      const isLocalhost = typeof window !== 'undefined' && window.location.hostname === 'localhost'\n      const useSecure = isProduction && !isLocalhost\n      \n      // ENHANCED FIX: Always store refresh token in localStorage first\n      localStorage.setItem('refresh_token', tokenResponse.refresh_token)\n      console.log('✅ Refresh token stored in localStorage')\n      \n      // ALSO try cookies\n      try {\n        Cookies.set('refresh_token', tokenResponse.refresh_token, {\n          expires: 7, // 7 days\n          secure: useSecure,\n          sameSite: 'lax'\n        })\n        \n        const storedRefreshToken = Cookies.get('refresh_token')\n        if (storedRefreshToken) {\n          console.log('✅ Refresh token also stored in cookies')\n        } else {\n          console.log('⚠️  Refresh token cookie storage failed - localStorage will be used')\n        }\n      } catch (cookieError) {\n        console.log('⚠️  Refresh token cookie error (using localStorage):', cookieError)\n      }\n    }\n    \n    // Store token expiry for refresh logic with defensive validation\n    try {\n      const expiresInSeconds = tokenResponse.expires_in || 3600 // Default to 1 hour if not provided\n      const expiresInMilliseconds = Number(expiresInSeconds) * 1000\n      \n      // Validate that we have a valid number\n      if (isNaN(expiresInMilliseconds) || expiresInMilliseconds <= 0) {\n        throw new Error(`Invalid expires_in value: ${tokenResponse.expires_in}`)\n      }\n      \n      const expiryTime = new Date(Date.now() + expiresInMilliseconds)\n      \n      // Validate the date is valid before converting to ISO string\n      if (isNaN(expiryTime.getTime())) {\n        throw new Error(`Invalid expiry date calculated from expires_in: ${tokenResponse.expires_in}`)\n      }\n      \n      localStorage.setItem('token_expires_at', expiryTime.toISOString())\n      \n      console.log(`Token expiry set: ${expiryTime.toISOString()} (expires_in: ${expiresInSeconds}s)`)\n    } catch (error) {\n      console.error('Error setting token expiry time:', error)\n      // Fallback: set expiry to 1 hour from now\n      const fallbackExpiry = new Date(Date.now() + 3600000) // 1 hour\n      localStorage.setItem('token_expires_at', fallbackExpiry.toISOString())\n      console.warn(`Using fallback token expiry: ${fallbackExpiry.toISOString()}`)\n    }\n  }\n\n  private setUserData(user: User, tenant: any, permissions: string[]): void {\n    localStorage.setItem('current_user', JSON.stringify(user))\n    localStorage.setItem('tenant_info', JSON.stringify(tenant))\n    localStorage.setItem('user_permissions', JSON.stringify(permissions))\n  }\n\n  private getStoredUser(): User | null {\n    try {\n      const userData = localStorage.getItem('current_user')\n      return userData ? JSON.parse(userData) : null\n    } catch {\n      return null\n    }\n  }\n\n  private clearTokens(): void {\n    Cookies.remove('access_token')\n    Cookies.remove('refresh_token')\n    localStorage.removeItem('access_token')\n    localStorage.removeItem('refresh_token')\n    localStorage.removeItem('token_expires_at')\n  }\n\n  private clearUserData(): void {\n    localStorage.removeItem('current_user')\n    localStorage.removeItem('tenant_info')\n    localStorage.removeItem('user_permissions')\n  }\n\n  // Enhanced auto-refresh with tenant validation and better error handling\n  initializeAutoRefresh(): void {\n    // PRODUCTION FIX: Completely disable auto-refresh to avoid timer issues\n    // The app works fine without background token refresh\n    // Users can manually refresh by navigating or re-logging in\n    console.log('Auto-refresh disabled - manual token refresh only')\n    \n    // Auto-refresh is not critical for functionality\n    // Tokens have reasonable expiry times and users can re-login if needed\n    return\n  }\n\n  // Enhanced session timeout detection\n  private sessionTimeoutThreshold = 30 * 60 * 1000 // 30 minutes\n  private lastActivityTime = Date.now()\n\n  trackUserActivity(): void {\n    this.lastActivityTime = Date.now()\n  }\n\n  checkSessionTimeout(): boolean {\n    const now = Date.now()\n    const timeSinceLastActivity = now - this.lastActivityTime\n    return timeSinceLastActivity > this.sessionTimeoutThreshold\n  }\n\n  initializeActivityTracking(): void {\n    // EMERGENCY FIX: Activity tracking disabled to resolve persistent setInterval production errors\n    // This prevents the \"TypeError: setInterval(...) is not a function\" error in production\n    console.log('Activity tracking disabled - emergency production fix')\n    \n    // Simple activity tracking without timers - just update activity time on page load\n    if (typeof window !== 'undefined' && process.env.NODE_ENV !== 'test') {\n      this.trackUserActivity()\n    }\n    \n    return\n  }\n}\n\nexport const authService = new AuthService()\n\n// Note: Timer initialization moved to client-side components to prevent SSR issues"],"names":["AuthService","authService","emergencyAuthLogin","loginData","console","log","baseUrl","process","env","NEXT_PUBLIC_API_BASE_URL","authUrl","formData","URLSearchParams","append","code","redirect_uri","state","response","fetch","method","headers","credentials","body","ok","errorText","text","error","status","Error","result","json","hasAccessToken","access_token","hasRefreshToken","refresh_token","hasUser","user","tokenType","token_type","expiresIn","expires_in","keys","Object","login","authCodeKey","substring","processedAuthCodes","has","warn","loginPromise","delete","add","setTokens","verifyToken","getToken","setUserData","tenant","permissions","size","clear","message","includes","refreshToken","refreshTokenPromise","getRefreshToken","apiService","post","clearTokens","getCurrentUser","get","refreshError","getAuth0Url","redirectUri","additionalScopes","organizationHint","params","length","join","logout","allDevices","all_devices","performCompleteSessionCleanup","window","location","href","clearUserData","keysToRemove","forEach","key","localStorage","removeItem","sessionStorage","refreshInterval","__authRefreshInterval","timeoutInterval","__sessionTimeoutInterval","clearInterval","clearCache","history","replaceState","currentUrl","pathname","info","checkSession","extendSession","localToken","getItem","debug","cookieToken","Cookies","undefined","isAuthenticated","token","getStoredUser","getUserPermissions","JSON","parse","hasPermission","permission","hasAnyPermission","requiredPermissions","userPermissions","some","perm","getUserRole","role","getTenantInfo","tenantData","shouldRefreshToken","tokenExpiry","expiryTime","Date","getTime","currentTime","now","tokenRefreshThreshold","ensureValidToken","tokenResponse","isProduction","NODE_ENV","isLocalhost","hostname","useSecure","setItem","set","expires","secure","sameSite","storedToken","cookieError","storedRefreshToken","expiresInSeconds","expiresInMilliseconds","Number","isNaN","toISOString","fallbackExpiry","stringify","userData","remove","initializeAutoRefresh","trackUserActivity","lastActivityTime","checkSessionTimeout","timeSinceLastActivity","sessionTimeoutThreshold","initializeActivityTracking","Set"],"mappings":"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"}