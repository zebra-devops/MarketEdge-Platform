{"version":3,"sources":["/Users/matt/Sites/MarketEdge/platform-wrapper/frontend/src/services/feature-flag-api.ts"],"sourcesContent":["import { apiService } from './api'\nimport { \n  FeatureFlagEvaluationResponse, \n  EnabledFeaturesResponse,\n  FeatureFlagError\n} from '@/types/feature-flags'\n\nclass FeatureFlagApiService {\n  /**\n   * Check if a specific feature flag is enabled for the current user\n   */\n  async checkFeatureFlag(flagKey: string): Promise<FeatureFlagEvaluationResponse> {\n    try {\n      const response = await apiService.get<FeatureFlagEvaluationResponse>(`/features/${flagKey}`)\n      return response\n    } catch (error: any) {\n      // Convert API errors to FeatureFlagError\n      if (error.response?.status === 404) {\n        throw new FeatureFlagError(`Feature flag '${flagKey}' not found`, flagKey, 404)\n      }\n      if (error.response?.status === 403) {\n        throw new FeatureFlagError(`Access denied for feature flag '${flagKey}'`, flagKey, 403)\n      }\n      throw new FeatureFlagError(\n        error.message || `Failed to check feature flag '${flagKey}'`,\n        flagKey,\n        error.response?.status\n      )\n    }\n  }\n\n  /**\n   * Get all enabled features for the current user\n   */\n  async getEnabledFeatures(moduleId?: string): Promise<EnabledFeaturesResponse> {\n    try {\n      const url = moduleId ? `/features/enabled?module_id=${moduleId}` : '/features/enabled'\n      const response = await apiService.get<EnabledFeaturesResponse>(url)\n      return response\n    } catch (error: any) {\n      throw new FeatureFlagError(\n        error.message || 'Failed to get enabled features',\n        undefined,\n        error.response?.status\n      )\n    }\n  }\n\n  /**\n   * Batch check multiple feature flags\n   */\n  async checkMultipleFlags(flagKeys: string[]): Promise<Record<string, FeatureFlagEvaluationResponse>> {\n    try {\n      // Since the backend doesn't have a bulk endpoint, we'll make parallel requests\n      const promises = flagKeys.map(async (flagKey) => {\n        try {\n          const result = await this.checkFeatureFlag(flagKey)\n          return { flagKey, result }\n        } catch (error) {\n          // Return disabled for non-existent flags instead of throwing\n          if (error instanceof FeatureFlagError && error.statusCode === 404) {\n            return {\n              flagKey,\n              result: {\n                flag_key: flagKey,\n                enabled: false,\n                user_id: '',\n                reason: 'Flag not found'\n              }\n            }\n          }\n          throw error\n        }\n      })\n\n      const results = await Promise.all(promises)\n      \n      // Convert to record format\n      return results.reduce((acc, { flagKey, result }) => {\n        acc[flagKey] = result\n        return acc\n      }, {} as Record<string, FeatureFlagEvaluationResponse>)\n      \n    } catch (error: any) {\n      throw new FeatureFlagError(\n        error.message || 'Failed to check multiple feature flags',\n        undefined,\n        error.response?.status\n      )\n    }\n  }\n\n  /**\n   * Preload flags into cache (for performance)\n   */\n  async preloadFlags(flagKeys: string[]): Promise<void> {\n    try {\n      // Fire parallel requests without waiting for results\n      // This helps with cache warming\n      flagKeys.forEach(flagKey => {\n        this.checkFeatureFlag(flagKey).catch(error => {\n          // Silently fail for preloading - we don't want to break the app\n          console.warn(`Failed to preload flag '${flagKey}':`, error.message)\n        })\n      })\n    } catch (error) {\n      // Silent failure for preloading\n      console.warn('Failed to preload flags:', error)\n    }\n  }\n\n  /**\n   * Health check for feature flag service\n   */\n  async healthCheck(): Promise<{ status: 'healthy' | 'degraded'; timestamp: string }> {\n    try {\n      // Try to get enabled features as a health check\n      await this.getEnabledFeatures()\n      return {\n        status: 'healthy',\n        timestamp: new Date().toISOString()\n      }\n    } catch (error) {\n      return {\n        status: 'degraded',\n        timestamp: new Date().toISOString()\n      }\n    }\n  }\n}\n\nexport const featureFlagApiService = new FeatureFlagApiService()"],"names":["featureFlagApiService","FeatureFlagApiService","checkFeatureFlag","flagKey","response","apiService","get","error","status","FeatureFlagError","message","getEnabledFeatures","moduleId","url","undefined","checkMultipleFlags","flagKeys","promises","map","result","statusCode","flag_key","enabled","user_id","reason","results","Promise","all","reduce","acc","preloadFlags","forEach","catch","console","warn","healthCheck","timestamp","Date","toISOString"],"mappings":"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"}